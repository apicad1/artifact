On a multi-processor system the operating system usually distributes the different processes which are runnable on all available CPUs in a way which allows the system to work most efficiently.  Which processes and threads run can be to some extend be control with the scheduling functionality described in the last sections.  But which CPU finally executes which process or thread is not covered. 
There are a number of reasons why a program might want to have control over this aspect of the system as well: 
  One thread or process is responsible for absolutely critical work which under no circumstances must be interrupted or hindered from making progress by other processes or threads using CPU resources.  In this case the special process would be confined to a CPU which no other process or thread is allowed to use.   The access to certain resources (RAM, I/O ports) has different costs from different CPUs.  This is the case in NUMA (Non-Uniform Memory Architecture) machines.  Preferably memory should be accessed locally but this requirement is usually not visible to the scheduler. Therefore forcing a process or thread to the CPUs which have local access to the most-used memory helps to significantly boost the performance.   In controlled runtimes resource allocation and book-keeping work (for instance garbage collection) is performance local to processors.  This can help to reduce locking costs if the resources do not have to be protected from concurrent accesses from different processors. 
The POSIX standard up to this date is of not much help to solve this problem.  The Linux kernel provides a set of interfaces to allow specifying affinity sets for a process.  The scheduler will schedule the thread or process on CPUs specified by the affinity masks.  The interfaces which the GNU C Library define follow to some extent the Linux kernel interface. 
To manipulate the bitset, to set and reset bits, a number of macros are defined.  Some of the macros take a CPU number as a parameter.  Here it is important to never exceed the size of the bitset.  The following macro specifies the number of bits in the cpu_set_t bitset. 
The type cpu_set_t should be considered opaque; all manipulation should happen via the next four macros. 
CPU bitsets can be constructed from scratch or the currently installed affinity mask can be retrieved from the system. 
Note that it is not portably possible to use this information to retrieve the information for different POSIX threads.  A separate interface must be provided for that. 
