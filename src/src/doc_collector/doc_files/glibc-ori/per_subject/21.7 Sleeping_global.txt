The function sleep gives a simple way to make the program wait for a short interval.  If your program doesn’t use signals (except to terminate), then you can expect sleep to wait reliably throughout the specified interval.  Otherwise, sleep can return sooner if a signal arrives; if you want to wait for a given interval regardless of signals, use select (see Waiting for I/O) and don’t specify any descriptors to wait for. 
Resist the temptation to implement a sleep for a fixed amount of time by using the return value of sleep, when nonzero, to call sleep again.  This will work with a certain amount of accuracy as long as signals arrive infrequently.  But each signal can cause the eventual wakeup time to be off by an additional second or so.  Suppose a few signals happen to arrive in rapid succession by bad luck—there is no limit on how much this could shorten or lengthen the wait. 
Instead, compute the calendar time at which the program should stop waiting, and keep trying to wait until that calendar time.  This won’t be off by more than a second.  With just a little more work, you can use select and make the waiting period quite accurate.  (Of course, heavy system load can cause additional unavoidable delays—unless the machine is dedicated to one application, there is no way you can avoid this.) 
On some systems, sleep can do strange things if your program uses SIGALRM explicitly.  Even if SIGALRM signals are being ignored or blocked when sleep is called, sleep might return prematurely on delivery of a SIGALRM signal.  If you have established a handler for SIGALRM signals and a SIGALRM signal is delivered while the process is sleeping, the action taken might be just to cause sleep to return instead of invoking your handler.  And, if sleep is interrupted by delivery of a signal whose handler requests an alarm or alters the handling of SIGALRM, this handler and sleep will interfere. 
On GNU systems, it is safe to use sleep and SIGALRM in the same program, because sleep does not work by means of SIGALRM. 
