The collection of signals that are currently blocked is called the signal mask.  Each process has its own signal mask.  When you create a new process (see Creating a Process), it inherits its parent’s mask.  You can block or unblock signals with total flexibility by modifying the signal mask. 
The prototype for the sigprocmask function is in signal.h.  
Note that you must not use sigprocmask in multi-threaded processes, because each thread has its own signal mask and there is no single process signal mask.  According to POSIX, the behavior of sigprocmask in a multi-threaded process is “unspecified”. Instead, use pthread_sigmask. 

>>>>>>>>>>>>>>>>>>>>
- Function: int sigprocmask (int how, const sigset_t *restrict set, sigset_t *restrict oldset)
Preliminary: | MT-Unsafe race:sigprocmask/bsd(SIG_UNBLOCK) | AS-Unsafe lock/hurd | AC-Unsafe lock/hurd | See POSIX Safety Concepts. 
The sigprocmask function is used to examine or change the calling process’s signal mask.  The how argument determines how the signal mask is changed, and must be one of the following values: 
	SIG_BLOCK  
 Block the signals in set—add them to the existing mask.  In other words, the new mask is the union of the existing mask and set.  
	SIG_UNBLOCK  
 Unblock the signals in set—remove them from the existing mask.  
	SIG_SETMASK  
 Use set for the mask; ignore the previous value of the mask. 
The last argument, oldset, is used to return information about the old process signal mask.  If you just want to change the mask without looking at it, pass a null pointer as the oldset argument. Similarly, if you want to know what’s in the mask without changing it, pass a null pointer for set (in this case the how argument is not significant).  The oldset argument is often used to remember the previous signal mask in order to restore it later.  (Since the signal mask is inherited over fork and exec calls, you can’t predict what its contents are when your program starts running.) 
If invoking sigprocmask causes any pending signals to be unblocked, at least one of those signals is delivered to the process before sigprocmask returns.  The order in which pending signals are delivered is not specified, but you can control the order explicitly by making multiple sigprocmask calls to unblock various signals one at a time. 
The sigprocmask function returns 0 if successful, and -1 to indicate an error.  The following errno error conditions are defined for this function: 
	EINVAL
The how argument is invalid. 
You can’t block the SIGKILL and SIGSTOP signals, but if the signal set includes these, sigprocmask just ignores them instead of returning an error status. 
Remember, too, that blocking program error signals such as SIGFPE leads to undesirable results for signals generated by an actual program error (as opposed to signals sent with raise or kill). This is because your program may be too broken to be able to continue executing to a point where the signal is unblocked again. See Program Error Signals. 
