
>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGFPE
The SIGFPE signal reports a fatal arithmetic error.  Although the name is derived from “floating-point exception”, this signal actually covers all arithmetic errors, including division by zero and overflow. If a program stores integer data in a location which is then used in a floating-point operation, this often causes an “invalid operation” exception, because the processor cannot recognize the data as a floating-point number.   
Actual floating-point exceptions are a complicated subject because there are many types of exceptions with subtly different meanings, and the SIGFPE signal doesn’t distinguish between them.  The IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985 and ANSI/IEEE Std 854-1987) defines various floating-point exceptions and requires conforming computer systems to report their occurrences.  However, this standard does not specify how the exceptions are reported, or what kinds of handling and control the operating system can offer to the programmer. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_INTOVF_TRAP  
Integer overflow (impossible in a C program unless you enable overflow trapping in a hardware-specific fashion). 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_INTDIV_TRAP  
Integer division by zero. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_SUBRNG_TRAP  
Subscript-range (something that C programs never check for). 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_FLTOVF_TRAP  
Floating overflow trap. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_FLTDIV_TRAP  
Floating/decimal division by zero. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_FLTUND_TRAP  
Floating underflow trap.  (Trapping on floating underflow is not normally enabled.) 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- FPE_DECOVF_TRAP  
Decimal overflow trap.  (Only a few machines have decimal arithmetic and C never uses it.) 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGILL
The name of this signal is derived from “illegal instruction”; it usually means your program is trying to execute garbage or a privileged instruction.  Since the C compiler generates only valid instructions, SIGILL typically indicates that the executable file is corrupted, or that you are trying to execute data.  Some common ways of getting into the latter situation are by passing an invalid object where a pointer to a function was expected, or by writing past the end of an automatic array (or similar problems with pointers to automatic variables) and corrupting other data on the stack such as the return address of a stack frame. 
SIGILL can also be generated when the stack overflows, or when the system has trouble running the handler for a signal. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGSEGV

This signal is generated when a program tries to read or write outside the memory that is allocated for it, or to write memory that can only be read.  (Actually, the signals only occur when the program goes far enough outside to be detected by the system’s memory protection mechanism.)  The name is an abbreviation for “segmentation violation”. 
Common ways of getting a SIGSEGV condition include dereferencing a null or uninitialized pointer, or when you use a pointer to step through an array, but fail to check for the end of the array.  It varies among systems whether dereferencing a null pointer generates SIGSEGV or SIGBUS. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGBUS
This signal is generated when an invalid pointer is dereferenced.  Like SIGSEGV, this signal is typically the result of dereferencing an uninitialized pointer.  The difference between the two is that SIGSEGV indicates an invalid access to valid memory, while SIGBUS indicates an access to an invalid address.  In particular, SIGBUS signals often result from dereferencing a misaligned pointer, such as referring to a four-word integer at an address not divisible by four.  (Each kind of computer has its own requirements for address alignment.) 
The name of this signal is an abbreviation for “bus error”. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGABRT

This signal indicates an error detected by the program itself and reported by calling abort.  See Aborting a Program. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGIOT
Generated by the PDP-11 “iot” instruction.  On most machines, this is just another name for SIGABRT. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGTRAP
Generated by the machine’s breakpoint instruction, and possibly other trap instructions.  This signal is used by debuggers.  Your program will probably only see SIGTRAP if it is somehow executing bad instructions. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGEMT
Emulator trap; this results from certain unimplemented instructions which might be emulated in software, or the operating system’s failure to properly emulate them. 
<<<<<<<<<<<<<<<<<<<<


>>>>>>>>>>>>>>>>>>>>
- Macro: int SIGSYS
Bad system call; that is to say, the instruction to trap to the operating system was executed, but the code number for the system call to perform was invalid. 
