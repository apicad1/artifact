This set of functions follows the traditional cycle of using a resource: open–use–close.  The interface consists of three functions, each of which implements one step. 
Before the interfaces are described it is necessary to introduce a data type.  Just like other open–use–close interfaces the functions introduced here work using handles and the iconv.h header defines a special type for the handles used. 
The first step is the function to create a handle. 
The iconv implementation can associate large data structure with the handle returned by iconv_open.  Therefore, it is crucial to free all the resources once all conversions are carried out and the conversion is not needed anymore. 
The standard defines only one actual conversion function.  This has, therefore, the most general interface: it allows conversion from one buffer to another.  Conversion from a file to a buffer, vice versa, or even file to file can be implemented on top of it. 
The definition of the iconv function is quite good overall.  It provides quite flexible functionality.  The only problems lie in the boundary cases, which are incomplete byte sequences at the end of the input buffer and invalid input.  A third problem, which is not really a design problem, is the way conversions are selected.  The standard does not say anything about the legitimate names, a minimal set of available conversions.  We will see how this negatively impacts other implementations, as demonstrated below. 
