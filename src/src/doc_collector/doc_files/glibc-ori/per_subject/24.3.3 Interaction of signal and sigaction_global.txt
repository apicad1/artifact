It’s possible to use both the signal and sigaction functions within a single program, but you have to be careful because they can interact in slightly strange ways. 
The sigaction function specifies more information than the signal function, so the return value from signal cannot express the full range of sigaction possibilities.  Therefore, if you use signal to save and later reestablish an action, it may not be able to reestablish properly a handler that was established with sigaction. 
To avoid having problems as a result, always use sigaction to save and restore a handler if your program uses sigaction at all. Since sigaction is more general, it can properly save and reestablish any action, regardless of whether it was established originally with signal or sigaction. 
On some systems if you establish an action with signal and then examine it with sigaction, the handler address that you get may not be the same as what you specified with signal.  It may not even be suitable for use as an action argument with signal.  But you can rely on using it as an argument to sigaction.  This problem never happens on GNU systems. 
So, you’re better off using one or the other of the mechanisms consistently within a single program. 
Portability Note: The basic signal function is a feature of ISO C, while sigaction is part of the POSIX.1 standard.  If you are concerned about portability to non-POSIX systems, then you should use the signal function instead. 
