You can use fflush to clean a stream in most cases. 
You can skip the fflush if you know the stream is already clean.  A stream is clean whenever its buffer is empty.  For example, an unbuffered stream is always clean.  An input stream that is at end-of-file is clean.  A line-buffered stream is clean when the last character output was a newline.  However, a just-opened input stream might not be clean, as its input buffer might not be empty. 
There is one case in which cleaning a stream is impossible on most systems.  This is when the stream is doing input from a file that is not random-access.  Such streams typically read ahead, and when the file is not random access, there is no way to give back the excess data already read.  When an input stream reads from a random-access file, fflush does clean the stream, but leaves the file pointer at an unpredictable place; you must set the file pointer before doing any further I/O. 
Closing an output-only stream also does fflush, so this is a valid way of cleaning an output stream. 
You need not clean a stream before using its descriptor for control operations such as setting terminal modes; these operations don’t affect the file position and are not affected by it.  You can use any descriptor for these operations, and all channels are affected simultaneously.  However, text already “output” to a stream but still buffered by the stream will be subject to the new terminal modes when subsequently flushed.  To make sure “past” output is covered by the terminal settings that were in effect at the time, flush the output streams for that terminal before setting the modes.  See Terminal Modes. 
