Floating-point calculations are carried out internally with extra precision, and then rounded to fit into the destination type.  This ensures that results are as precise as the input data.  IEEE 754 defines four possible rounding modes: 
fenv.h defines constants which you can use to refer to the various rounding modes.  Each one will be defined if and only if the FPU supports the corresponding rounding mode. 
Underflow is an unusual case.  Normally, IEEE 754 floating point numbers are always normalized (see Floating Point Concepts). Numbers smaller than 2^r (where r is the minimum exponent, FLT_MIN_RADIX-1 for float) cannot be represented as normalized numbers.  Rounding all such numbers to zero or 2^r would cause some algorithms to fail at 0.  Therefore, they are left in denormalized form.  That produces loss of precision, since some bits of the mantissa are stolen to indicate the decimal point. 
If a result is too small to be represented as a denormalized number, it is rounded to zero.  However, the sign of the result is preserved; if the calculation was negative, the result is negative zero. Negative zero can also result from some operations on infinity, such as 4/-∞. 
At any time, one of the above four rounding modes is selected.  You can find out which one with this function: 
To change the rounding mode, use this function: 
You should avoid changing the rounding mode if possible.  It can be an expensive operation; also, some hardware requires you to compile your program differently for it to work.  The resulting code may run slower. See your compiler documentation for details. 
