The fundamental purpose of an interactive shell is to read commands from the user’s terminal and create processes to execute the programs specified by those commands.  It can do this using the fork (see Creating a Process) and exec (see Executing a File) functions. 
A single command may run just one process—but often one command uses several processes.  If you use the ‘|’ operator in a shell command, you explicitly request several programs in their own processes.  But even if you run just one program, it can use multiple processes internally.  For example, a single compilation command such as ‘cc -c foo.c’ typically uses four processes (though normally only two at any given time).  If you run make, its job is to run other programs in separate processes. 
The processes belonging to a single command are called a process group or job.  This is so that you can operate on all of them at once.  For example, typing C-c sends the signal SIGINT to terminate all the processes in the foreground process group. 
A session is a larger group of processes.  Normally all the processes that stem from a single login belong to the same session. 
Every process belongs to a process group.  When a process is created, it becomes a member of the same process group and session as its parent process.  You can put it in another process group using the setpgid function, provided the process group belongs to the same session. 
The only way to put a process in a different session is to make it the initial process of a new session, or a session leader, using the setsid function.  This also puts the session leader into a new process group, and you can’t move it out of that process group again. 
Usually, new sessions are created by the system login program, and the session leader is the process running the user’s login shell. 
A shell that supports job control must arrange to control which job can use the terminal at any time.  Otherwise there might be multiple jobs trying to read from the terminal at once, and confusion about which process should receive the input typed by the user.  To prevent this, the shell must cooperate with the terminal driver using the protocol described in this chapter. 
The shell can give unlimited access to the controlling terminal to only one process group at a time.  This is called the foreground job on that controlling terminal.  Other process groups managed by the shell that are executing without such access to the terminal are called background jobs. 
If a background job needs to read from its controlling terminal, it is stopped by the terminal driver; if the TOSTOP mode is set, likewise for writing.  The user can stop a foreground job by typing the SUSP character (see Special Characters) and a program can stop any job by sending it a SIGSTOP signal.  It’s the responsibility of the shell to notice when jobs stop, to notify the user about them, and to provide mechanisms for allowing the user to interactively continue stopped jobs and switch jobs between foreground and background. 
See Access to the Terminal, for more information about I/O to the controlling terminal. 
