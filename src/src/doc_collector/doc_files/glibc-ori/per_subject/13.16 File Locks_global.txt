This section describes record locks that are associated with the process. There is also a different type of record lock that is associated with the open file description instead of the process.  See Open File Description Locks. 
The remaining fcntl commands are used to support record locking, which permits multiple cooperating programs to prevent each other from simultaneously accessing parts of a file in error-prone ways. 
An exclusive or write lock gives a process exclusive access for writing to the specified part of the file.  While a write lock is in place, no other process can lock that part of the file. 
A shared or read lock prohibits any other process from requesting a write lock on the specified part of the file.  However, other processes can request read locks. 
The read and write functions do not actually check to see whether there are any locks in place.  If you want to implement a locking protocol for a file shared by multiple processes, your application must do explicit fcntl calls to request and clear locks at the appropriate points. 
Locks are associated with processes.  A process can only have one kind of lock set for each byte of a given file.  When any file descriptor for that file is closed by the process, all of the locks that process holds on that file are released, even if the locks were made using other descriptors that remain open.  Likewise, locks are released when a process exits, and are not inherited by child processes created using fork (see Creating a Process). 
When making a lock, use a struct flock to specify what kind of lock and where.  This data type and the associated macros for the fcntl function are declared in the header file fcntl.h.  
The following macros are defined for use as values for the l_type member of the flock structure.  The values are integer constants. 
As an example of a situation where file locking is useful, consider a program that can be run simultaneously by several different users, that logs status information to a common file.  One example of such a program might be a game that uses a file to keep track of high scores.  Another example might be a program that records usage or accounting information for billing purposes. 
Having multiple copies of the program simultaneously writing to the file could cause the contents of the file to become mixed up.  But you can prevent this kind of problem by setting a write lock on the file before actually writing to the file. 
If the program also needs to read the file and wants to make sure that the contents of the file are in a consistent state, then it can also use a read lock.  While the read lock is set, no other process can lock that part of the file for writing. 
Remember that file locks are only an advisory protocol for controlling access to a file.  There is still potential for access to the file by programs that donâ€™t use the lock protocol. 
