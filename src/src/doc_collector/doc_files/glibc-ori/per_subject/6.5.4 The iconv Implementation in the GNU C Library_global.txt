After reading about the problems of iconv implementations in the last section it is certainly good to note that the implementation in the GNU C Library has none of the problems mentioned above.  What follows is a step-by-step analysis of the points raised above.  The evaluation is based on the current state of the development (as of January 1999).  The development of the iconv functions is not complete, but basic functionality has solidified. 
The GNU C Library’s iconv implementation uses shared loadable modules to implement the conversions.  A very small number of conversions are built into the library itself but these are only rather trivial conversions. 
All the benefits of loadable modules are available in the GNU C Library implementation.  This is especially appealing since the interface is well documented (see below), and it, therefore, is easy to write new conversion modules.  The drawback of using loadable objects is not a problem in the GNU C Library, at least on ELF systems.  Since the library is able to load shared objects even in statically linked binaries, static linking need not be forbidden in case one wants to use iconv. 
The second mentioned problem is the number of supported conversions. Currently, the GNU C Library supports more than 150 character sets.  The way the implementation is designed the number of supported conversions is greater than 22350 (150 times 149).  If any conversion from or to a character set is missing, it can be added easily. 
Particularly impressive as it may be, this high number is due to the fact that the GNU C Library implementation of iconv does not have the third problem mentioned above (i.e., whenever there is a conversion from a character set A to B and from B to C it is always possible to convert from A to C directly).  If the iconv_open returns an error and sets errno to EINVAL, there is no known way, directly or indirectly, to perform the wanted conversion. 
Triangulation is achieved by providing for each character set a conversion from and to UCS-4 encoded ISO 10646.  Using ISO 10646 as an intermediate representation it is possible to triangulate (i.e., convert with an intermediate representation). 
There is no inherent requirement to provide a conversion to ISO 10646 for a new character set, and it is also possible to provide other conversions where neither source nor destination character set is ISO 10646.  The existing set of conversions is simply meant to cover all conversions that might be of interest. 
All currently available conversions use the triangulation method above, making conversion run unnecessarily slow.  If, for example, somebody often needs the conversion from ISO-2022-JP to EUC-JP, a quicker solution would involve direct conversion between the two character sets, skipping the input to ISO 10646 first.  The two character sets of interest are much more similar to each other than to ISO 10646. 
In such a situation one easily can write a new conversion and provide it as a better alternative.  The GNU C Library iconv implementation would automatically use the module implementing the conversion if it is specified to be more efficient. 
All information about the available conversions comes from a file named gconv-modules, which can be found in any of the directories along the GCONV_PATH.  The gconv-modules files are line-oriented text files, where each of the lines has one of the following formats: 
  If the first non-whitespace character is a # the line contains only comments and is ignored.   Lines starting with alias define an alias name for a character set.  Two more words are expected on the line.  The first word defines the alias name, and the second defines the original name of the character set.  The effect is that it is possible to use the alias name in the fromset or toset parameters of iconv_open and achieve the same result as when using the real character set name.  This is quite important as a character set has often many different names.  There is normally an official name but this need not correspond to the most popular name.  Besides this many character sets have special names that are somehow constructed.  For example, all character sets specified by the ISO have an alias of the form ISO-IR-nnn where nnn is the registration number.  This allows programs that know about the registration number to construct character set names and use them in iconv_open calls.  More on the available names and aliases follows below.   Lines starting with module introduce an available conversion module.  These lines must contain three or four more words.  The first word specifies the source character set, the second word the destination character set of conversion implemented in this module, and the third word is the name of the loadable module.  The filename is constructed by appending the usual shared object suffix (normally .so) and this file is then supposed to be found in the same directory the gconv-modules file is in.  The last word on the line, which is optional, is a numeric value representing the cost of the conversion.  If this word is missing, a cost of 1 is assumed.  The numeric value itself does not matter that much; what counts are the relative values of the sums of costs for all possible conversion paths. Below is a more precise description of the use of the cost value. 
Returning to the example above where one has written a module to directly convert from ISO-2022-JP to EUC-JP and back.  All that has to be done is to put the new module, let its name be ISO2022JP-EUCJP.so, in a directory and add a file gconv-modules with the following content in the same directory: 

EXAMPLE_BEGIN
module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
EXAMPLE_END

To see why this is sufficient, it is necessary to understand how the conversion used by iconv (and described in the descriptor) is selected.  The approach to this problem is quite simple. 
At the first call of the iconv_open function the program reads all available gconv-modules files and builds up two tables: one containing all the known aliases and another that contains the information about the conversions and which shared object implements them. 
The set of available conversions form a directed graph with weighted edges.  The weights on the edges are the costs specified in the gconv-modules files.  The iconv_open function uses an algorithm suitable for search for the best path in such a graph and so constructs a list of conversions that must be performed in succession to get the transformation from the source to the destination character set. 
Explaining why the above gconv-modules files allows the iconv implementation to resolve the specific ISO-2022-JP to EUC-JP conversion module instead of the conversion coming with the library itself is straightforward.  Since the latter conversion takes two steps (from ISO-2022-JP to ISO 10646 and then from ISO 10646 to EUC-JP), the cost is 1+1 = 2.  The above gconv-modules file, however, specifies that the new conversion modules can perform this conversion with only the cost of 1. 
A mysterious item about the gconv-modules file above (and also the file coming with the GNU C Library) are the names of the character sets specified in the module lines.  Why do almost all the names end in //?  And this is not all: the names can actually be regular expressions.  At this point in time this mystery should not be revealed, unless you have the relevant spell-casting materials: ashes from an original DOS 6.2 boot disk burnt in effigy, a crucifix blessed by St. Emacs, assorted herbal roots from Central America, sand from Cebu, etc.  Sorry!  The part of the implementation where this is used is not yet finished.  For now please simply follow the existing examples.  It’ll become clearer once it is. –drepper 
A last remark about the gconv-modules is about the names not ending with //.  A character set named INTERNAL is often mentioned.  From the discussion above and the chosen name it should have become clear that this is the name for the representation used in the intermediate step of the triangulation.  We have said that this is UCS-4 but actually that is not quite right.  The UCS-4 specification also includes the specification of the byte ordering used.  Since a UCS-4 value consists of four bytes, a stored value is affected by byte ordering.  The internal representation is not the same as UCS-4 in case the byte ordering of the processor (or at least the running process) is not the same as the one required for UCS-4.  This is done for performance reasons as one does not want to perform unnecessary byte-swapping operations if one is not interested in actually seeing the result in UCS-4.  To avoid trouble with endianness, the internal representation consistently is named INTERNAL even on big-endian systems where the representations are identical. 
So far this section has described how modules are located and considered to be used.  What remains to be described is the interface of the modules so that one can write new ones.  This section describes the interface as it is in use in January 1999.  The interface will change a bit in the future but, with luck, only in an upwardly compatible way. 
The definitions necessary to write new modules are publicly available in the non-standard header gconv.h.  The following text, therefore, describes the definitions from this header file.  First, however, it is necessary to get an overview. 
From the perspective of the user of iconv the interface is quite simple: the iconv_open function returns a handle that can be used in calls to iconv, and finally the handle is freed with a call to iconv_close.  The problem is that the handle has to be able to represent the possibly long sequences of conversion steps and also the state of each conversion since the handle is all that is passed to the iconv function.  Therefore, the data structures are really the elements necessary to understanding the implementation. 
We need two different kinds of data structures.  The first describes the conversion and the second describes the state etc.  There are really two type definitions like this in gconv.h.  
With the knowledge about the data structures we now can describe the conversion function itself.  To understand the interface a bit of knowledge is necessary about the functionality in the C library that loads the objects with the conversions. 
It is often the case that one conversion is used more than once (i.e., there are several iconv_open calls for the same set of character sets during one program run).  The mbsrtowcs et.al. functions in the GNU C Library also use the iconv functionality, which increases the number of uses of the same functions even more. 
Because of this multiple use of conversions, the modules do not get loaded exclusively for one conversion.  Instead a module once loaded can be used by an arbitrary number of iconv or mbsrtowcs calls at the same time.  The splitting of the information between conversion- function-specific information and conversion data makes this possible. The last section showed the two data structures used to do this. 
This is of course also reflected in the interface and semantics of the functions that the modules must provide.  There are three functions that must have the following names: 
There are three data types defined for the three module interface functions and these define the interface. 
The function called before the module is unloaded is significantly easier.  It often has nothing at all to do; in which case it can be left out completely. 
The most important function is the conversion function itself, which can get quite complicated for complex character sets.  But since this is not of interest here, we will only describe a possible skeleton for the conversion function. 
This information should be sufficient to write new modules.  Anybody doing so should also take a look at the available source code in the GNU C Library sources.  It contains many examples of working and optimized modules. 
